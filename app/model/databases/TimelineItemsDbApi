package model.databases

import anorm.{Macro, RowParser, SQL}
import javax.inject.Inject
import model.dataModels.TimelineItem
import play.api.db.DBApi

class TimelineItemsDbApi @Inject() (dbApi: DBApi) extends PostgresDatabase(dbApi) {

  val timelineItemParser: RowParser[TimelineItem] = Macro.namedParser[TimelineItem]

  def addTimelineItem(timelineItem: TimelineItem): Option[Long] =
    db.withConnection { implicit connection =>
      SQL("insert into timeline_items(business_id, project_id, time, date, duration, description, contact, notes, modified_date, created_date) " +
        "values ({business_id} , {project_id}, {time}, {date}, {duration}, {contact}, {notes}, {modified_date}, {created_date})")
        .on("project_id" -> timelineItem.project_id,  "business_id" -> timelineItem.business_id, "duration"  -> timelineItem.duration, "date" -> timelineItem.date,
          "time" -> timelineItem.time, "date" -> timelineItem.date, "duration" -> timelineItem.duration, "contact" -> timelineItem.contact, "notes" -> timelineItem.notes,
          "modified_date" -> payment.modified_date, "created_date" -> payment.created_date)
        .executeInsert()
    }

  def byId(timelineItemId: Long): Option[TimelineItem] =
    db.withConnection { implicit connection =>
      SQL("select * from  timeline_items where id = {id}").on("id" -> timelineItemId).as(timelineItemParser.singleOpt)
    }

  def allItems(): Seq[TimelineItem] =
    db.withConnection { implicit connection =>
      SQL("select * from  timeline_items").as(timelineItemParser.*)
    }

  def updateItem(updatedTimelineItem: TimelineItem): Int =
    db.withConnection { implicit connection =>
      SQL("update timeline_items set time = {time}, date = {date}, duration = {duration}, description = {description}" +
        " contact = {contact}, notes = {notes}, modified_date = {modified_date} where id = {id} and budget_id = {budget_id}")
        .on("payment_amount" -> updatedPayment.payment_amount, "payment_date"  -> updatedPayment.payment_date,
          "modified_date" -> updatedPayment.modified_date, "id" -> updatedPayment.id, "budget_id" -> updatedPayment.budget_id)
        .executeUpdate()
    }

  def deleteTimelineItem(id: Long, projectId: Long, businessId: Long): Int =
    db.withConnection { implicit connection =>
      SQL("delete from timeline_items where id = {id} and business_id = {business_id} and budget_id = {budgetId}")
        .on("id" -> id, "projectId" -> projectId, "business_id" -> businessId)
        .executeUpdate()
    }
}
